module;

#include <span>
#include <utility>
#include <algorithm>


#if defined(_MSC_VER) // DO NOT TOUCH

	#define FORCE_INLINE __forceinline

#elif defined(__GNUC__) || defined(__clang__)

	#define FORCE_INLINE __attribute__((always_inline)) inline

#else

	#define FORCE_INLINE inline

#endif


module ArxConverter.ArxExplode;


namespace Tables
{
	constexpr Array<UInt8, 0x40> DistBits =
	{{
		0x02, 0x04, 0x04, 0x05, 0x05, 0x05, 0x05, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06,
		0x06, 0x06, 0x06, 0x06, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07,
		0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08,
		0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08
	}};

	constexpr Array<UInt8, 0x40> DistCode =
	{{
		0x03, 0x0D, 0x05, 0x19, 0x09, 0x11, 0x01, 0x3E, 0x1E, 0x2E, 0x0E, 0x36, 0x16, 0x26, 0x06, 0x3A, 0x1A, 0x2A,
		0x0A, 0x32, 0x12, 0x22, 0x42, 0x02, 0x7C, 0x3C, 0x5C, 0x1C, 0x6C, 0x2C, 0x4C, 0x0C, 0x74, 0x34, 0x54, 0x14,
		0x64, 0x24, 0x44, 0x04, 0x78, 0x38, 0x58, 0x18, 0x68, 0x28, 0x48, 0x08, 0xF0, 0x70, 0xB0, 0x30, 0xD0, 0x50,
		0x90, 0x10, 0xE0, 0x60, 0xA0, 0x20, 0xC0, 0x40, 0x80, 0x00
	}};

	constexpr Array<UInt8, 0x10> ExLenBits =
	{{
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08
	}};

	constexpr Array<UInt16, 0x10> LenBase =
	{{
		0x0000, 0x0001, 0x0002, 0x0003, 0x0004, 0x0005, 0x0006, 0x0007, 0x0008, 0x000A, 0x000E, 0x0016, 0x0026, 0x0046, 0x0086, 0x0106
	}};

	constexpr Array<UInt8, 0x10> LenBits =
	{{
		0x03, 0x02, 0x03, 0x03, 0x04, 0x04, 0x04, 0x05, 0x05, 0x05, 0x05, 0x06, 0x06, 0x06, 0x07, 0x07
	}};

	constexpr Array<UInt8, 0x10> LenCode =
	{{
		0x05, 0x03, 0x01, 0x06, 0x0A, 0x02, 0x0C, 0x14, 0x04, 0x18, 0x08, 0x30, 0x10, 0x20, 0x40, 0x00
	}};

	constexpr Array<UInt8, 0x100> ChBitsAsc =
	{{
		0x0B, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x08, 0x07, 0x0C, 0x0C, 0x07, 0x0C, 0x0C, 0x0C, 0x0C,
		0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0D, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x04, 0x0A, 0x08, 0x0C,
		0x0A, 0x0C, 0x0A, 0x08, 0x07, 0x07, 0x08, 0x09, 0x07, 0x06, 0x07, 0x08, 0x07, 0x06, 0x07, 0x07, 0x07, 0x07,
		0x08, 0x07, 0x07, 0x08, 0x08, 0x0C, 0x0B, 0x07, 0x09, 0x0B, 0x0C, 0x06, 0x07, 0x06, 0x06, 0x05, 0x07, 0x08,
		0x08, 0x06, 0x0B, 0x09, 0x06, 0x07, 0x06, 0x06, 0x07, 0x0B, 0x06, 0x06, 0x06, 0x07, 0x09, 0x08, 0x09, 0x09,
		0x0B, 0x08, 0x0B, 0x09, 0x0C, 0x08, 0x0C, 0x05, 0x06, 0x06, 0x06, 0x05, 0x06, 0x06, 0x06, 0x05, 0x0B, 0x07,
		0x05, 0x06, 0x05, 0x05, 0x06, 0x0A, 0x05, 0x05, 0x05, 0x05, 0x08, 0x07, 0x08, 0x08, 0x0A, 0x0B, 0x0B, 0x0C,
		0x0C, 0x0C, 0x0D, 0x0D, 0x0D, 0x0D, 0x0D, 0x0D, 0x0D, 0x0D, 0x0D, 0x0D, 0x0D, 0x0D, 0x0D, 0x0D, 0x0D, 0x0D,
		0x0D, 0x0D, 0x0D, 0x0D, 0x0D, 0x0D, 0x0D, 0x0D, 0x0D, 0x0D, 0x0D, 0x0D, 0x0D, 0x0D, 0x0D, 0x0D, 0x0D, 0x0D,
		0x0D, 0x0D, 0x0D, 0x0D, 0x0D, 0x0D, 0x0D, 0x0D, 0x0D, 0x0D, 0x0D, 0x0D, 0x0D, 0x0D, 0x0C, 0x0C, 0x0C, 0x0C,
		0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C,
		0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C,
		0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0D, 0x0C, 0x0D, 0x0D, 0x0D, 0x0C, 0x0D, 0x0D, 0x0D, 0x0C,
		0x0D, 0x0D, 0x0D, 0x0D, 0x0C, 0x0D, 0x0D, 0x0D, 0x0C, 0x0C, 0x0C, 0x0D, 0x0D, 0x0D, 0x0D, 0x0D, 0x0D, 0x0D,
		0x0D, 0x0D, 0x0D, 0x0D
	}};

	constexpr Array<UInt16, 0x100> ChCodeAsc =
	{{
		0x0490, 0x0FE0, 0x07E0, 0x0BE0, 0x03E0, 0x0DE0, 0x05E0, 0x09E0, 0x01E0, 0x00B8, 0x0062, 0x0EE0, 0x06E0,
		0x0022, 0x0AE0, 0x02E0, 0x0CE0, 0x04E0, 0x08E0, 0x00E0, 0x0F60, 0x0760, 0x0B60, 0x0360, 0x0D60, 0x0560,
		0x1240, 0x0960, 0x0160, 0x0E60, 0x0660, 0x0A60, 0x000F, 0x0250, 0x0038, 0x0260, 0x0050, 0x0C60, 0x0390,
		0x00D8, 0x0042, 0x0002, 0x0058, 0x01B0, 0x007C, 0x0029, 0x003C, 0x0098, 0x005C, 0x0009, 0x001C, 0x006C,
		0x002C, 0x004C, 0x0018, 0x000C, 0x0074, 0x00E8, 0x0068, 0x0460, 0x0090, 0x0034, 0x00B0, 0x0710, 0x0860,
		0x0031, 0x0054, 0x0011, 0x0021, 0x0017, 0x0014, 0x00A8, 0x0028, 0x0001, 0x0310, 0x0130, 0x003E, 0x0064,
		0x001E, 0x002E, 0x0024, 0x0510, 0x000E, 0x0036, 0x0016, 0x0044, 0x0030, 0x00C8, 0x01D0, 0x00D0, 0x0110,
		0x0048, 0x0610, 0x0150, 0x0060, 0x0088, 0x0FA0, 0x0007, 0x0026, 0x0006, 0x003A, 0x001B, 0x001A, 0x002A,
		0x000A, 0x000B, 0x0210, 0x0004, 0x0013, 0x0032, 0x0003, 0x001D, 0x0012, 0x0190, 0x000D, 0x0015, 0x0005,
		0x0019, 0x0008, 0x0078, 0x00F0, 0x0070, 0x0290, 0x0410, 0x0010, 0x07A0, 0x0BA0, 0x03A0, 0x0240, 0x1C40,
		0x0C40, 0x1440, 0x0440, 0x1840, 0x0840, 0x1040, 0x0040, 0x1F80, 0x0F80, 0x1780, 0x0780, 0x1B80, 0x0B80,
		0x1380, 0x0380, 0x1D80, 0x0D80, 0x1580, 0x0580, 0x1980, 0x0980, 0x1180, 0x0180, 0x1E80, 0x0E80, 0x1680,
		0x0680, 0x1A80, 0x0A80, 0x1280, 0x0280, 0x1C80, 0x0C80, 0x1480, 0x0480, 0x1880, 0x0880, 0x1080, 0x0080,
		0x1F00, 0x0F00, 0x1700, 0x0700, 0x1B00, 0x0B00, 0x1300, 0x0DA0, 0x05A0, 0x09A0, 0x01A0, 0x0EA0, 0x06A0,
		0x0AA0, 0x02A0, 0x0CA0, 0x04A0, 0x08A0, 0x00A0, 0x0F20, 0x0720, 0x0B20, 0x0320, 0x0D20, 0x0520, 0x0920,
		0x0120, 0x0E20, 0x0620, 0x0A20, 0x0220, 0x0C20, 0x0420, 0x0820, 0x0020, 0x0FC0, 0x07C0, 0x0BC0, 0x03C0,
		0x0DC0, 0x05C0, 0x09C0, 0x01C0, 0x0EC0, 0x06C0, 0x0AC0, 0x02C0, 0x0CC0, 0x04C0, 0x08C0, 0x00C0, 0x0F40,
		0x0740, 0x0B40, 0x0340, 0x0300, 0x0D40, 0x1D00, 0x0D00, 0x1500, 0x0540, 0x0500, 0x1900, 0x0900, 0x0940,
		0x1100, 0x0100, 0x1E00, 0x0E00, 0x0140, 0x1600, 0x0600, 0x1A00, 0x0E40, 0x0640, 0x0A40, 0x0A00, 0x1200,
		0x0200, 0x1C00, 0x0C00, 0x1400, 0x0400, 0x1800, 0x0800, 0x1000, 0x0000
	}};
}


FORCE_INLINE Bool WasteBits(ArxExplode::State& state, UInt32 nBits) noexcept
{
	if (nBits <= state.extra_bits)
	{
		state.extra_bits -= nBits;

		state.bit_buff  >>= nBits;


		return true;
	}


	state.bit_buff >>= state.extra_bits;


	if (state.inputPtr < state.inputEnd)
	{
		state.bit_buff |= static_cast<UInt32>(static_cast<UInt8>(*state.inputPtr++)) << 8U;
	}
	else
	{
		return false;
	}


	state.bit_buff >>= (nBits - state.extra_bits);

	state.extra_bits = (state.extra_bits - nBits) + 8U;


	return true;
}


FORCE_INLINE UInt32 DecodeLit(ArxExplode::State& state) noexcept
{
	if (state.bit_buff & 1U)
	{
		if (!WasteBits(state, 1U))
		{
			return 0x306U;
		}


		const UInt32 lengthCode = state.LengthCodes[state.bit_buff & 0xFFU];


		if (!WasteBits(state, state.LenBits[lengthCode]))
		{
			return 0x306U;
		}


		UInt32 finalCode = lengthCode;


		if (const UInt32 extraLenBits = state.ExLenBits[lengthCode]; extraLenBits != 0U)
		{
			const UInt32 extraLength = state.bit_buff & ((1U << extraLenBits) - 1U);

			if (!WasteBits(state, extraLenBits))
			{
				if ((lengthCode + extraLength) != 0x10EU)
				{
					return 0x306U;
				}
			}

			finalCode = state.LenBase[lengthCode] + extraLength;
		}

		return finalCode + 0x100U;
	}


	if (!WasteBits(state, 1U))
	{
		return 0x306U;
	}


	if (state.type == 0U)
	{
		const UInt32 byteVal = state.bit_buff & 0xFFU;

		if (!WasteBits(state, 8U))
		{
			return 0x306U;
		}

		return byteVal;
	}


	UInt32 value = 0U;


	if (const UInt32 lowByte = state.bit_buff & 0xFFU)
	{
		value = state.Offs2C34[lowByte];

		if (value == 0xFFU)
		{
			if (state.bit_buff & 0x3FU)
			{
				if (!WasteBits(state, 4U))
				{
					return 0x306U;
				}

				value = state.Offs2D34[state.bit_buff & 0xFFU];
			}
			else
			{
				if (!WasteBits(state, 6U))
				{
					return 0x306U;
				}

				value = state.Offs2E34[state.bit_buff & 0x7FU];
			}
		}
	}
	else
	{
		if (!WasteBits(state, 8U))
		{
			return 0x306U;
		}

		value = state.Offs2EB4[state.bit_buff & 0xFFU];
	}


	if (!WasteBits(state, state.ChBitsAsc[value]))
	{
		return 0x306U;
	}

	return value;
}


FORCE_INLINE UInt32 DecodeDist(ArxExplode::State& state, UInt32 repLength) noexcept
{
	const UInt32 distPosCode = state.DistPosCodes[state.bit_buff & 0xFFU];


	if (const UInt32 distPosBits = state.DistBits[distPosCode]; !WasteBits(state, distPosBits))
	{
		return 0U;
	}


	UInt32 distance = 0U;


	if (repLength == 2U)
	{
		distance = (distPosCode << 2U) | (state.bit_buff & 0x03U);

		if (!WasteBits(state, 2U))
		{
			return 0U;
		}
	}
	else
	{
		distance = (distPosCode << state.dsize_bits) | (state.bit_buff & state.dsize_mask);

		if (!WasteBits(state, state.dsize_bits))
		{
			return 0U;
		}
	}


	return distance + 1U;
}


ArxExplode::ArxExplode(const DynamicArray<Byte>& compressed, Logger& logger) noexcept : m_compressed{ compressed }, m_logger{ logger }
{
	if (!m_compressed.empty())
	{
		m_decompressed.reserve(m_compressed.size() * 3ULL);
	}

	decompress();
}


DynamicArray<Byte> ArxExplode::releaseDecompressed() noexcept
{
	return std::move(m_decompressed);
}


Void ArxExplode::decompress()
{
	if (m_compressed.empty())
	{
		return;
	}


	State state{};

	state.inputPtr = m_compressed.data();

	state.inputEnd = state.inputPtr + m_compressed.size();


	if (state.inputPtr >= state.inputEnd)
	{
		return;
	}

	state.type = static_cast<UInt32>(static_cast<UInt8>(*state.inputPtr++));

	if (state.inputPtr >= state.inputEnd)
	{
		return;
	}

	state.dsize_bits = static_cast<UInt32>(static_cast<UInt8>(*state.inputPtr++));

	if (state.inputPtr >= state.inputEnd)
	{
		return;
	}

	state.bit_buff   = static_cast<UInt32>(static_cast<UInt8>(*state.inputPtr++));

	state.extra_bits = 0U;


	if (state.dsize_bits < 4U || state.dsize_bits > 6U)
	{
		m_logger.print<LogLevel::Error>("ArxExplode: Invalid dictionary size.");
	}


	state.dsize_mask = 0xFFFFU >> (0x10U - state.dsize_bits);


	if (state.type != 0U && state.type != 1U)
	{
		m_logger.print<LogLevel::Error>("ArxExplode: Invalid compression mode.");
	}


	std::ranges::copy(Tables::LenBits, state.LenBits.begin());

	std::ranges::copy(Tables::ExLenBits, state.ExLenBits.begin());

	std::ranges::copy(Tables::LenBase, state.LenBase.begin());

	std::ranges::copy(Tables::DistBits, state.DistBits.begin());


	if (state.type == 1U)
	{
		std::ranges::copy(Tables::ChBitsAsc, state.ChBitsAsc.begin());

		generateAsciiTables(state);
	}


	generateDecodeTables(state.LengthCodes,  Tables::LenCode,  Tables::LenBits);

	generateDecodeTables(state.DistPosCodes, Tables::DistCode, Tables::DistBits);


	auto& outVec = m_decompressed;

	Size  outPos = 0ULL;


	UInt32 nextLiteral;


	while (true)
	{
		nextLiteral = DecodeLit(state);


		if (nextLiteral >= 0x305U)
		{
			break;
		}


		if (nextLiteral < 0x100U)
		{
			const Byte b = static_cast<Byte>(nextLiteral);


			state.window[state.windowHead] = b;

			state.windowHead = (state.windowHead + 1ULL) & State::WindowMask;


			if (outPos == outVec.size()) [[unlikely]]
			{
				outVec.resize(outPos + 0x4000ULL);
			}

			outVec[outPos++] = b;
		}
		else
		{
			const UInt32 repLength = nextLiteral - 0xFEU;

			const UInt32 minusDist = DecodeDist(state, repLength);


			if (minusDist == 0U)
			{
				nextLiteral = 0x306U; // Error

				break;
			}


			UInt32 sourceIdx = (static_cast<UInt32>(state.windowHead) - minusDist) & static_cast<UInt32>(State::WindowMask);


			if (outPos + repLength > outVec.size()) [[unlikely]]
			{
				outVec.resize(std::max(outVec.size() + 0x4000ULL, outPos + repLength));
			}


			Byte* outPtr = outVec.data() + outPos;


			for (UInt32 i = 0; i < repLength; ++i)
			{
				const Byte b = state.window[sourceIdx];

				sourceIdx = (sourceIdx + 1U) & static_cast<UInt32>(State::WindowMask);


				state.window[state.windowHead] = b;

				state.windowHead = (state.windowHead + 1ULL) & State::WindowMask; // говно


				outPtr[i] = b;
			}


			outPos += repLength;
		}
	}


	outVec.resize(outPos);


	if (nextLiteral == 0x306U)
	{
		m_logger.print<LogLevel::Error>("ArxExplode: Decompression failed.");
	}
}


Void ArxExplode::generateDecodeTables(std::span<UInt8> positions, std::span<const UInt8> startIndexes, std::span<const UInt8> lengthBits)
{
	const Size count = startIndexes.size();


	for (Index i = 0; i < count; ++i)
	{
		const Size  length = 1ULL << lengthBits[i];

		const UInt8 idx    = static_cast<UInt8>(i);

		const UInt8 start  = startIndexes[i];


		for (Index index = start; index < 0x100ULL; index += length)
		{
			positions[index] = idx;
		}
	}
}


Void ArxExplode::generateAsciiTables(State& state)
{
	const UInt16* pChCodeAsc = &Tables::ChCodeAsc[0xFF];


	for (Int32 count = 0xFF; count >= 0; --pChCodeAsc, --count)
	{
		if (UInt8 bitsAsc = state.ChBitsAsc[count]; bitsAsc <= 8U)
		{
			const UInt32 add = (1U << bitsAsc);

			      UInt32 acc = *pChCodeAsc;

			do
			{
				state.Offs2C34[acc] = static_cast<UInt8>(count);

				acc += add;

			} while (acc < 0x100U);
		}
		else if (const UInt32 acc_tmp = (*pChCodeAsc & 0xFFU); acc_tmp != 0U)
		{
			state.Offs2C34[acc_tmp] = 0xFF;


			if (*pChCodeAsc & 0x3FU)
			{
				bitsAsc -= 4U;

				const UInt32 add = (1U << bitsAsc);

				      UInt32 acc = *pChCodeAsc >> 4U;

				do
				{
					state.Offs2D34[acc] = static_cast<UInt8>(count);

					acc += add;

				} while (acc < 0x100U);
			}
			else
			{
				bitsAsc -= 6U;

				const UInt32 add = (1U << bitsAsc);

				      UInt32 acc = *pChCodeAsc >> 6U;

				do
				{
					state.Offs2E34[acc] = static_cast<UInt8>(count);

					acc += add;

				} while (acc < 0x80U);
			}
		}
		else
		{
			bitsAsc -= 8U;

			const UInt32 add = (1U << bitsAsc);

			      UInt32 acc = *pChCodeAsc >> 8U;

			do
			{
				state.Offs2EB4[acc] = static_cast<UInt8>(count);

				acc += add;

			} while (acc < 0x100U);
		}
	}
}